/*
 * This file is part of Hootenanny.
 *
 * Hootenanny is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * --------------------------------------------------------------------
 *
 * The following copyright notices are generated automatically. If you
 * have a new notice to add, please use the format:
 * " * @copyright Copyright ..."
 * This will properly maintain the copyright information. DigitalGlobe
 * copyrights will be updated automatically.
 *
 * @copyright Copyright (C) 2012, 2013 DigitalGlobe (http://www.digitalglobe.com/)
 */

////
// This file is automatically generated. Please do not modify the file
// directly.
////

  // Hootenanny Javascript configuration options
var HOOT_HOME = process.env.HOOT_HOME;
var hoot = require(HOOT_HOME + '/lib/HootJs');

module.exports = {

  /**
   * Typically REF1/2 values are only applied to elements with informational tags (e.g.
   * name=foo),
   * however setting this to false will apply REF1/2 values to all elements.
   */
  getAddRefVisitorInformationOnly : function()
  {
      var tmp = hoot.get('add.ref.visitor.information.only');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * Prefix to apply to REF1 values.
   *
   * The REF1 values are typically used when training a model. See the
   * https://insightcloud.digitalglobe.com/redmine/projects/hootenany/wiki/Manual_Conflation[deve
   * loper
   * documentation] for details.
   */
  getAddRef1VisitorPrefix : function()
  {
      var tmp = hoot.get('add.ref1.visitor.prefix');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The maximum number of values returned for each attribute by the attribute-count command.
   */
  getAttributeCountValues : function()
  {
      var tmp = hoot.get('attribute.count.values');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 30;
  },

  /**
   * Determines whether the AttributeScoreExtractor uses weighting when extracting scores.
   */
  getAttributeScoreExtractorUseWeight : function()
  {
      var tmp = hoot.get('attribute.score.extractor.use.weight');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * The maximum distance that the BigPertyOp should move a node. This must be larger than sigma
   * to
   * avoid endless or near endless loops.
   */
  getBigPertyOpMaxDistance : function()
  {
      var tmp = hoot.get('big.perty.op.max.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return -1;
  },

  /**
   * Sigma of the distance in meters. This is used in the gaussian distribution used to determine
   * the
   * distance.
   */
  getBigPertyOpSigma : function()
  {
      var tmp = hoot.get('big.perty.op.sigma');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 100;
  },

  /**
   * The threshold at which a match is called a match for buildings.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getBuildingMatchThreshold : function()
  {
      var tmp = hoot.get('building.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}");
  },

  /**
   * The threshold at which a miss is called a miss for buildings.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getBuildingMissThreshold : function()
  {
      var tmp = hoot.get('building.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}");
  },

  /**
   * Path to the RF building model. A new model can be created with `build-model`. Searches local
   * path
   * and then `$HOOT_HOME/conf/`.
   *
   * Training a model is typically done during research. While all the tools are available to do
   * limited training, the documentation is not. Please contact the developers if you would like
   * to
   * dig deeper.
   */
  getBuildingModelPath : function()
  {
      var tmp = hoot.get('building.model.path');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "BuildingModel.rf";
  },

  /**
   * The threshold at which a review is called a review for buildings.  See
   * `conflate.review.threshold.default`.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getBuildingReviewThreshold : function()
  {
      var tmp = hoot.get('building.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}");
  },

  /**
   * The maximum allowed size of an OSM changeset written to the OSM API database.
   */
  getChangesetMaxSize : function()
  {
      var tmp = hoot.get('changeset.max.size');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 50000;
  },

  /**
   * The DB user ID for a OSM API DB. Used by changeset writing.
   */
  getChangesetUserId : function()
  {
      var tmp = hoot.get('changeset.user.id');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * Set the circular error tag on features to this value, in meters, by default if the tag isn't
   * already
   * populated.
   */
  getCircularErrorDefaultValue : function()
  {
      var tmp = hoot.get('circular.error.default.value');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 15;
  },

  /**
   * Add match/miss/review score values to elements with matches during Unifying Conflation. This
   * is
   * useful for debugging.
   */
  getConflateAddScoreTags : function()
  {
      var tmp = hoot.get('conflate.add.score.tags');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Enable the old road conflation. This is only necessary when using the `conflate` command.
   * See the
   * _Command Line Reference_ for details on the `conflate` command.
   *
   * By default the `conflate` command will first conflate roads using the circa 2012 conflation
   * algorithm and then conflate using the newer (circa 2014) unifying algorithm. If the unifying
   * algorithm has road conflation enable then the results could get interesting.
   */
  getConflateEnableOldRoads : function()
  {
      var tmp = hoot.get('conflate.enable.old.roads');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * The highway match classifier to use. This should only be used for testing and debugging.
   */
  getConflateMatchHighwayClassifier : function()
  {
      var tmp = hoot.get('conflate.match.highway.classifier');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::HighwayRfClassifier";
  },

  /**
   * The highway match classifier model file to use. This is only relevant if the
   * `conflate.match.highway.classifier` is set to `hoot::HighwayRfClassifier`. The configuration
   * path will be searched for this file (`$HOOT_HOME/conf/`).
   */
  getConflateMatchHighwayModel : function()
  {
      var tmp = hoot.get('conflate.match.highway.model');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "HighwayModel.rf";
  },

  /**
   * The POI match classifier model file to use. The configuration path will be searched for this
   * file (`$HOOT_HOME/conf/`).
   */
  getConflateMatchPoiModel : function()
  {
      var tmp = hoot.get('conflate.match.poi.model');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "PoiModel.rf";
  },

  /**
   * The default threshold at which a match is called a match.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getConflateMatchThresholdDefault : function()
  {
      var tmp = hoot.get('conflate.match.threshold.default');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.6;
  },

  /**
   * The default threshold at which a miss is called a miss.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getConflateMissThresholdDefault : function()
  {
      var tmp = hoot.get('conflate.miss.threshold.default');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.6;
  },

  /**
   * Runs in the conflate command after data is conflated, but before exporting.
   */
  getConflatePostOps : function()
  {
      var tmp = hoot.get('conflate.post.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::RemoveMissingElementsVisitor;hoot::RemoveEmptyReviewRelationsVisitor;hoot::RemoveDuplicateReviewsOp;hoot::BuildingOutlineUpdateOp;hoot::AddHilbertReviewSortOrderOp";
  },

  /**
   * Runs in the conflate command after data is loaded, but before the conflation. The default,
   * `hoot::MapCleaner` runs a number of common map cleaning operations.
   *
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getConflatePreOps : function()
  {
      var tmp = hoot.get('conflate.pre.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::BuildingOutlineRemoveOp;hoot::MapCleaner";
  },

  /**
   * The default threshold at which a review is called a review. Reviews are also declared in
   * some
   * other situations when the relationship is not clear.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getConflateReviewThresholdDefault : function()
  {
      var tmp = hoot.get('conflate.review.threshold.default');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.6;
  },

  /**
   * The string that lists the types of conflation used in the user interface.  The possible
   * values
   * are: reference, cookieCutter, average, and advancedConflation.
   */
  getConflateStatsTypes : function()
  {
      var tmp = hoot.get('conflate.stats.types');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Determines whether the conflate command will use the element ID's specified by the input
   * datasets
   * (true) or use internal ID management for the inputs (false).
   */
  getConflateUseDataSourceIds : function()
  {
      var tmp = hoot.get('conflate.use.data.source.ids');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * List of manipulators to enable in the conflator.
   *
   * Some of the possible options include:
   *
   * * `hoot::WayMerger` -
   * * `hoot::WayTagMerger` -
   */
  getConflatorManipulators : function()
  {
      var tmp = hoot.get('conflator.manipulators');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::WayMerger";
  },

  /**
   * This is the minimum valid manipulation score in the legacy greedy optimization routine.
   * Setting
   * the value lower will create more (likely overzealous) matches. Setting the value higher will
   * drop
   * less confident matches.
   */
  getConflatorMinValidScore : function()
  {
      var tmp = hoot.get('conflator.min.valid.score');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.01;
  },

  /**
   * List of user specified operations to run post conflation.
   */
  getConflatorPostOps : function()
  {
      var tmp = hoot.get('conflator.post.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * If specified the convert reader will limit data read from the data source to only features
   * that
   * intersect the given bounding box. The format is "minx,miny,maxx,maxy" specified in the
   * projection
   * of the input data source.
   *
   * Example Usage:
   *
   * ----
   * hoot convert -D convert.bounding.box=106.851,-6.160,107.052,-5.913 input.osm output.osm
   * ----
   */
  getConvertBoundingBox : function()
  {
      var tmp = hoot.get('convert.bounding.box');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Specifies one or more semi-colon delimited operations to perform before writing data. This
   * is only
   * applicable to the convert command.
   */
  getConvertOps : function()
  {
      var tmp = hoot.get('convert.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The size in meters used for alpha by the cookie cutter map operation (CookieCutterOp). A
   * larger
   * value makes a smoother shape and a smaller value will create a rough shape with more holes.
   * Value
   * in meters.
   */
  getCookieCutterAlpha : function()
  {
      var tmp = hoot.get('cookie.cutter.alpha');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1000.0;
  },

  /**
   * The buffer to add to the alpha shape before cutting by the cookie cutter map operation
   * (CookieCutterOp). A negative value will make the shape smaller.  Value in meters.
   */
  getCookieCutterAlphaShapeBuffer : function()
  {
      var tmp = hoot.get('cookie.cutter.alpha.shape.buffer');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.0;
  },

  /**
   * Crops based on the polygon rather than doing a cookie cut when using the cookie cutter map
   * operation (CookieCutterOp).
   */
  getCookieCutterOutputCrop : function()
  {
      var tmp = hoot.get('cookie.cutter.output.crop');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Creates example review tags for debugging. All reviews created with this mechanism are
   * invalid.
   */
  getCreateBogusReviewTags : function()
  {
      var tmp = hoot.get('create.bogus.review.tags');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Bounds used by the map cropper when cropping a map, of the form: minx,miny,maxx,maxy
   */
  getCropBounds : function()
  {
      var tmp = hoot.get('crop.bounds');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Debugging: The filename to use when saving the debug map during conflation.
   */
  getDebugMapFilename : function()
  {
      var tmp = hoot.get('debug.map.filename');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "tmp/debug.osm";
  },

  /**
   * When splitting divided highways do we assume the drivers are on the right or left.
   *
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getDualWaySplitterDrivingSide : function()
  {
      var tmp = hoot.get('dual.way.splitter.driving.side');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "right";
  },

  /**
   * By default how much space should be put between two divided roads when they're divided by
   * the
   * DividedHighwaySplitter. Units are in meters.
   *
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getDualWaySplitterSplitSize : function()
  {
      var tmp = hoot.get('dual.way.splitter.split.size');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 12.5;
  },

  /**
   * If true, all cleaning and conflation merge operations will only remove duplicate names when
   * their
   * case also matches.  If false, cleaning and conflation merge operations will consider names
   * with
   * the same text but differing case as the same with each other.
   *
   * See also: <<MapCleanerTransforms,map.cleaner.transforms>>
   */
  getDuplicateNameCaseSensitive : function()
  {
      var tmp = hoot.get('duplicate.name.case.sensitive');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * If true, when comparing duplicate ways, the ways and their name tags will only be merged
   * together
   * when all other non-name tags between the two match.  If false, the ways and their name tags
   * will be
   * merged together regardless of whether all of their non-name tags match.
   */
  getDuplicateWayRemoverStrictTagMatching : function()
  {
      var tmp = hoot.get('duplicate.way.remover.strict.tag.matching');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * The spacing used by the EdgeDistanceExtractor.  Units in meters.
   */
  getEdgeDistanceExtractorSpacing : function()
  {
      var tmp = hoot.get('edge.distance.extractor.spacing');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 5.0;
  },

  /**
   * Size of the cache used when streaming I/O is used with nodes.
   */
  getElementCacheSizeNode : function()
  {
      var tmp = hoot.get('element.cache.size.node');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 2000000;
  },

  /**
   * Size of the cache used when streaming I/O is used with relations.
   */
  getElementCacheSizeRelation : function()
  {
      var tmp = hoot.get('element.cache.size.relation');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 200000;
  },

  /**
   * Size of the cache used when streaming I/O is used with ways.
   */
  getElementCacheSizeWay : function()
  {
      var tmp = hoot.get('element.cache.size.way');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 200000;
  },

  /**
   * Absolute file path to dictionaries of English words. The first file found will be loaded
   * into the
   * dictionary of English words and used by some algorithms. If the files are not found then the
   * English
   * words will be silently ignored.
   *
   * For CentOS 6.X use `sudo yum install words` to install the dictionary. For Ubuntu 14.04 use
   * `sudo apt-get install wamerican-insane`.
   */
  getEnglishWordsFiles : function()
  {
      var tmp = hoot.get('english.words.files');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "/usr/share/dict/american-english-insane;/usr/share/dict/american-english-huge;/usr/share/dict/american-english-large;/usr/share/dict/american-english-small;/usr/share/dict/american-english;/usr/share/dict/words";
  },

  /**
   * The threshold at which a match is called a match for generic lines.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericLineMatchThreshold : function()
  {
      var tmp = hoot.get('generic.line.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}");
  },

  /**
   * Sets that maximum angle that is still considered a generic line match. Units in degrees.
   */
  getGenericLineMatcherMaxAngle : function()
  {
      var tmp = hoot.get('generic.line.matcher.max.angle');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 90.0;
  },

  /**
   * The threshold at which a miss is called a miss for generic lines.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericLineMissThreshold : function()
  {
      var tmp = hoot.get('generic.line.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}");
  },

  /**
   * The threshold at which a review is called a review for generic lines. See
   * `conflate.review.threshold.default`.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericLineReviewThreshold : function()
  {
      var tmp = hoot.get('generic.line.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}");
  },

  /**
   * The way subline matcher to use when determining matching sublines.
   */
  getGenericLineSublineMatcher : function()
  {
      var tmp = hoot.get('generic.line.subline.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineMatcher";
  },

  /**
   * The threshold at which a match is called a match for generic polygons.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericPolygonMatchThreshold : function()
  {
      var tmp = hoot.get('generic.polygon.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}");
  },

  /**
   * The threshold at which a miss is called a miss for generic polygons.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericPolygonMissThreshold : function()
  {
      var tmp = hoot.get('generic.polygon.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}");
  },

  /**
   * The threshold at which a review is called a review for generic polygons. See
   * `conflate.review.threshold.default`.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getGenericPolygonReviewThreshold : function()
  {
      var tmp = hoot.get('generic.polygon.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}");
  },

  /**
   * The threshold at which a match is called a match for roads.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getHighwayMatchThreshold : function()
  {
      var tmp = hoot.get('highway.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.161;
  },

  /**
   * The distance around a point on a highway to look when calculating the heading.  See
   * `way.matcher.heading.delta`.
   */
  getHighwayMatcherHeadingDelta : function()
  {
      var tmp = hoot.get('highway.matcher.heading.delta');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.matcher.heading.delta}");
  },

  /**
   * Sets that maximum angle that is still considered a highway match. Units in degrees.
   */
  getHighwayMatcherMaxAngle : function()
  {
      var tmp = hoot.get('highway.matcher.max.angle');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.matcher.max.angle}");
  },

  /**
   * If two highways have significantly different enumerated types then they will not be
   * considered
   * for match. For example:
   *
   * * "highway=primary" vs "highway=secondary" has a diff of 0.2.
   * * "highway=primary" vs "highway=footway" has a diff of 0.67.
   */
  getHighwayMaxEnumDiff : function()
  {
      var tmp = hoot.get('highway.max.enum.diff');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.6;
  },

  /**
   * The threshold at which a miss is called a miss for roads.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getHighwayMissThreshold : function()
  {
      var tmp = hoot.get('highway.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.999;
  },

  /**
   * The threshold at which a review is called a review for roads. See
   * `conflate.review.threshold.default`.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getHighwayReviewThreshold : function()
  {
      var tmp = hoot.get('highway.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.25;
  },

  /**
   * The highway subline matcher to use when determining matching sublines.
   */
  getHighwaySublineMatcher : function()
  {
      var tmp = hoot.get('highway.subline.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.subline.matcher}");
  },

  /**
   * The way subline string matcher to use when determining matching sublines for highways.
   */
  getHighwaySublineStringMatcher : function()
  {
      var tmp = hoot.get('highway.subline.string.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${way.subline.string.matcher}");
  },

  /**
   * Used by the building matching code.
   */
  getHootHadoopFileDeps : function()
  {
      var tmp = hoot.get('hoot.hadoop.file.deps');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/conf/BuildingModel.rf");
  },

  /**
   * List of library paths to check for hadoop
   */
  getHootHadoopLibpath : function()
  {
      var tmp = hoot.get('hoot.hadoop.libpath');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/lib/;${HOOT_HOME}/local/lib/;${HADOOP_HOME}/c++/Linux-amd64-64/lib/;${HOOT_HOME}/pretty-pipes/lib/");
  },

  /**
   * The maximum number of nodes that can be processed by a single task tracker. See User Manual
   * for
   * details.",
   */
  getHootHadoopMaxNodeCount : function()
  {
      var tmp = hoot.get('hoot.hadoop.maxNodeCount');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 5000000;
  },

  /**
   * The size of a pixel when calculating node density. See User Manual for details.
   */
  getHootHadoopPixelSize : function()
  {
      var tmp = hoot.get('hoot.hadoop.pixelSize');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.01;
  },

  /**
   * Email address of the DG reader user.  Can be set here for debugging and testing.
   */
  getHootapiDbReaderEmail : function()
  {
      var tmp = hoot.get('hootapi.db.reader.email');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The maximum number of OSM elements that may be read from the hootapi services database into
   * a
   * single OSM map during a partial map read.
   */
  getHootapiDbReaderMaxElementsPerPartialMap : function()
  {
      var tmp = hoot.get('hootapi.db.reader.max.elements.per.partial.map');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 50000;
  },

  /**
   * Should the hootapi services DB writer automatically create the specified user if it doesn't
   * exist.
   * This is most useful when debugging and testing.
   */
  getHootapiDbWriterCreateUser : function()
  {
      var tmp = hoot.get('hootapi.db.writer.create.user');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Email address of the DG writer user.  Can be set here for debugging and testing.
   */
  getHootapiDbWriterEmail : function()
  {
      var tmp = hoot.get('hootapi.db.writer.email');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * If this value is set to a non-empty string, the system will attempt to open a file with the
   * specified name and output all the ID mappings (source to destination) used for nodes, ways,
   * and
   * relations that were written to the database.
   */
  getHootapiDbWriterOutputIdMappings : function()
  {
      var tmp = hoot.get('hootapi.db.writer.output.id.mappings');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * If set to true then if there is already a map with the specified name then it will be
   * removed before
   * a new map is written.
   */
  getHootapiDbWriterOverwriteMap : function()
  {
      var tmp = hoot.get('hootapi.db.writer.overwrite.map');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Sets the default ID generator class name. This determines how Hootenanny will assign new
   * element
   * IDs as they're created. The `DefaultIdGenerator` assigns IDs in a decrementing fashion (e.g.
   * -1,
   * -2, ...). The `hoot::PositiveIdGenerator` increments the IDs (e.g. 1, 2, 3, ...).
   *
   * Both generators maintain a different count for each element type. E.g. you can have a Node
   * with ID
   * 1 and a Way with ID 1. This will not cause any problems within Hootenanny and is a
   * legitimate way
   * of assigning IDs within OSM.
   *
   * Example Usage:
   *
   * ----
   * hoot ogr2osm -D id.generator=hoot::PositiveIdGenerator -D id.generator.node.start=100 -D
   * id.generator.relation.start=200 -D id.generator.way.start=300
   * $HOOT_HOME/translations/Identity.js myoutput.osm myinput.osm
   * ----
   */
  getIdGenerator : function()
  {
      var tmp = hoot.get('id.generator');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::DefaultIdGenerator";
  },

  /**
   * Sets the default start ID for nodes. The first value assigned is generator specific. (E.g.
   * for
   * default the first assigned id will be -1)
   */
  getIdGeneratorNodeStart : function()
  {
      var tmp = hoot.get('id.generator.node.start');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * Sets the default start ID for relations. The first value assigned is generator specific.
   * (E.g.
   * for default the first assigned id will be -1)
   */
  getIdGeneratorRelationStart : function()
  {
      var tmp = hoot.get('id.generator.relation.start');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * Sets the default start ID for ways. The first value assigned is generator specific. (E.g.
   * for
   * default the first assigned id will be -1)
   */
  getIdGeneratorWayStart : function()
  {
      var tmp = hoot.get('id.generator.way.start');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * A list of paths to include in the javascript translator search path.
   */
  getJavascriptTranslatorPath : function()
  {
      var tmp = hoot.get('javascript.translator.path');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_TRANSLATE_PATH};${HOOT_HOME}/plugins;${HOOT_HOME}/plugins-local");
  },

  /**
   * A list of tag keys for which the KeepTagsVisitor will retain on elements, while removing all
   * other tags from elements.
   */
  getKeepTagsVisitorKeys : function()
  {
      var tmp = hoot.get('keep.tags.visitor.keys');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Raise the levenshtein score to this power before returning this result. If alpha is greater
   * than
   * 1 then this makes low scores even lower. Valid values are > 0.
   *
   * The default alpha value of 1.15 was determined through experimentation with a Jakarta data
   * set
   * using MeanWordSetDistance as the container classes. See ticket #2349 for some experiment
   * details.
   * The "best" value varies depending on the input data as well as how the data is being used.
   */
  getLevenshteinDistanceAlpha : function()
  {
      var tmp = hoot.get('levenshtein.distance.alpha');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1.15;
  },

  /**
   * If available, uses the formatting as defined in
   * https://svn.apache.org/repos/asf/logging/site/trunk/docs/log4cxx/apidocs/classlog4cxx_1_1_pa
   * ttern_layout.html[log4cxx]
   * to set the log format. If log4cxx isn't available then this has no effect.
   *
   * Some example format strings and the associated output are below:
   *
   * -----
   * # Default log message with lots of information
   * %d{HH:mm:ss.SSS} %-5p ...%.30F(%4L) %m%n
   * 12:36:03.565 INFO  ...conflate/UnifyingConflator.cpp( 154) Pre-constraining match count: 11
   *
   * # Log message w/ minimal information
   * %-5p..%.20F(%3L) %m%n
   * INFO ..nifyingConflator.cpp(154) Pre-constraining match count: 11
   *
   * # Embed arbitrary strings in the log messages
   * Foo: %m%n
   * Foo: Pre-constraining match count: 11
   *
   * # Print out time elapsed in ms along w/ other info
   * %6r %-5p..%.20F(%3L) %m%n
   *    289 INFO ..nifyingConflator.cpp(154) Pre-constraining match count: 11
   *
   * # XML-ish log message. This allows parsing messages that span multiple lines,
   * # but you aren't guaranteed that all output from hoot goes through the logging
   * # mechanism.
   * <message time='%d' level='%p' file='%F' line='%L'>%m</message>%n
   * <message time='2014-10-28 13:09:35,339' level='INFO'
   * file='src/main/cpp/hoot/core/conflate/UnifyingConflator.cpp' line='154'>Pre-constraining
   * match count: 11</message>
   * -----
   *
   * [[MapCleanerTransforms]]
   */
  getLogFormat : function()
  {
      var tmp = hoot.get('log.format');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "%d{HH:mm:ss.SSS} %-5p ...%.30F(%4L) %m%n";
  },

  /**
   * A list of map operations to be applied to a map for cleaning purposes in order
   *
   * [[match.creators]]
   */
  getMapCleanerTransforms : function()
  {
      var tmp = hoot.get('map.cleaner.transforms');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ReprojectToPlanarOp;hoot::DuplicateWayRemover;hoot::SuperfluousWayRemover;hoot::IntersectionSplitter;hoot::UnlikelyIntersectionRemover;hoot::DualWaySplitter;hoot::ImpliedDividedMarker;hoot::DuplicateNameRemover;hoot::SmallWayMerger;hoot::RemoveEmptyAreasVisitor;hoot::RemoveDuplicateAreaVisitor;hoot::NoInformationElementRemover";
  },

  /**
   * List of MatchCreators to use during conflation. This can modify what features will be
   * conflated (e.g. buildings, roads, etc.).
   *
   * Some of the possible options include:
   *
   * * `hoot::BuildingMatchCreator` - Matches building polygons.
   * * `hoot::PlacesPoiMatchCreator` - Matches POIs using the PLACES algorithm.
   * * `hoot::HighwayMatchCreator` - Matches linear highway features using the Unify
   *   algorithm.
   * * `hoot::ScriptMatchCreator,PoiGeneric.js` - Matches POIs using the Unify
   *   algorithm.
   * * `hoot::ScriptMatchCreator,<yourscript.js>` - Uses a custom match script. The
   *   script should be in `$HOOT_HOME/rules/<yourscript.js>`.
   */
  getMatchCreators : function()
  {
      var tmp = hoot.get('match.creators');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::BuildingMatchCreator;hoot::PlacesPoiMatchCreator;hoot::HighwayMatchCreator";
  },

  /**
   * Used in the calculation of the parallel score, cos (delta) ^ match.parallel.exponent
   */
  getMatchParallelExponent : function()
  {
      var tmp = hoot.get('match.parallel.exponent');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * Maximum number of elements that will be read into memory at one time during a partial OSM
   * map reading. This shouldn't need to be changed. Reducing the value may cause errors on some
   * data formats that read large numbers of entries at one time. Increasing the value will use
   * more RAM in some situations.
   */
  getMaxElementsPerPartialMap : function()
  {
      var tmp = hoot.get('max.elements.per.partial.map');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 100000;
  },

  /**
   * Artificially limit the amount of virtual memory that Hootenanny will use. If Hootenanny
   * needs more
   * than this amount of virtual memory then a bad_alloc will likely be thrown. In some cases
   * you'll
   * receive a totally unrelated error message.
   *
   * Size is specified in bytes unless followed by one of these suffixes.
   *
   * * KB = size * 1000
   * * MB = size * 1000 * 1000
   * * GB = size * 1000 * 1000 * 1000
   *
   * For instance setting the value to 500KB is equivalent to 500000 bytes.
   *
   * The Linux utility RLIMIT_AS is used for limiting virtual memory. This is analagous to RAM,
   * but
   * less RAM will be utilized than the value specified. Typically this is most useful when
   * limiting
   * RAM usage of applications in a shared server environment.
   */
  getMaxMemoryUsage : function()
  {
      var tmp = hoot.get('max.memory.usage');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "-1";
  },

  /**
   * When merging nodes during --ogr2osm, what tolerance should be used for deciding two nodes
   * are identical. Units in meters and defaults to 1.0m.
   *
   * [[merger.creators]]
   */
  getMergeNearbyNodesDistance : function()
  {
      var tmp = hoot.get('merge.nearby.nodes.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1.0;
  },

  /**
   * List of MergerCreators to use during conflation. This can modify what features will be
   * conflated (e.g. buildings, roads, etc.).
   *
   * Possible values include:
   *
   * * `hoot::BuildingMergerCreator` - Required if `hoot::BuildingMatchCreator` is
   *   specified in `match.creators`.
   * * `hoot::PlacesPoiMergerCreator` - Required if `hoot::PlacesPoiMatchCreator` is
   *   specified in `match.creators`.
   * * `hoot::HighwaySnapMergerCreator` - Required if `hoot::HighwayMatchCreator`
   *   is specified in `match.creators`.
   * * `hoot::ScriptMergerCreator` - Required if one or more instances of
   *   `hoot::SplitMatchCreator` is specified in `match.creators`. Note that the
   *   script name is not specified in this parameter.
   */
  getMergerCreators : function()
  {
      var tmp = hoot.get('merger.creators');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::BuildingMergerCreator;hoot::PlacesPoiMergerCreator;hoot::HighwaySnapMergerCreator";
  },

  /**
   * A larger value will conflate more aggressively (fewer reviews). Users may want to consider
   * changing
   * this value. Reasonable range is [1, ~10].
   */
  getNetworkConflictsAggression : function()
  {
      var tmp = hoot.get('network.conflicts.aggression');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 4.4;
  },

  /**
   * A value of 0 will cause an edge to contribute (1 * score * weight) to each neighbor. A value
   * of 1 will give approx (1 / n * score * weight) influence to each neighbor.
   * Reasonable range is [0, 2].
   */
  getNetworkConflictsOutboundWeighting : function()
  {
      var tmp = hoot.get('network.conflicts.outbound.weighting');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * A larger value will increase the weight of partial matches. A smaller value prefers whole
   * matches
   * over partial matches. This value is generally not changed by users. Reasonable range is (0,
   * ~2].
   */
  getNetworkConflictsPartialHandicap : function()
  {
      var tmp = hoot.get('network.conflicts.partial.handicap');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.2;
  },

  /**
   * A larger value will increase the weight of stubs. This value is generally not changed by
   * users. Reasonable range is (0, ~2].
   */
  getNetworkConflictsStubHandicap : function()
  {
      var tmp = hoot.get('network.conflicts.stub.handicap');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return .86;
  },

  /**
   * A value of 0 will cause edges that are connected by a stub to contribute directly as
   * neighbors.
   * Higher values will reduce that contribution. Reasonable range is [0, ~10].
   */
  getNetworkConflictsStubThroughWeighting : function()
  {
      var tmp = hoot.get('network.conflicts.stub.through.weighting');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.59;
  },

  /**
   * A value of 0 will cause all edges to have the same weight with each neighbor, a higher value
   * will
   * give matches with more support a higher weight. This value is generally not changed by
   * users. Reasonable range is [0, 2].
   */
  getNetworkConflictsWeightInfluence : function()
  {
      var tmp = hoot.get('network.conflicts.weight.influence');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * The threshold at which a network match is called a match.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getNetworkMatchThreshold : function()
  {
      var tmp = hoot.get('network.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.15;
  },

  /**
   * If true debug maps will be generated at every iteration. This is useful when debugging. The
   * maps
   * can be large and slow things down significantly.
   */
  getNetworkMatchWriteDebugMaps : function()
  {
      var tmp = hoot.get('network.match.write.debug.maps');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * An internal option for manipulating the way network matching occurs. This should only be
   * used for
   * debug and test. The parameter must be a class that is registered with the factory and
   * subclasses
   * `NetworkMatcher`.
   */
  getNetworkMatcher : function()
  {
      var tmp = hoot.get('network.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::IterativeNetworkMatcher";
  },

  /**
   * The maximum allowable length of a stub connection (way to node match). Value in meters.
   */
  getNetworkMaxStubLength : function()
  {
      var tmp = hoot.get('network.max.stub.length');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 20;
  },

  /**
   * The threshold at which a network miss is called a miss.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getNetworkMissThreshold : function()
  {
      var tmp = hoot.get('network.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.85;
  },

  /**
   * The threshold at which a network review is called a review. Reviews are also declared in
   * some
   * other situations when the relationship is not clear.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getNetworkReviewThreshold : function()
  {
      var tmp = hoot.get('network.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.5;
  },

  /**
   * Determines how strictly the angle should be considered when calculating intersection tie
   * points for
   * rubber sheeting. A value of 0 will ignore angle entirely. Large will make the angle
   * comparison more
   * strict.
   */
  getNodeMatcherStrictness : function()
  {
      var tmp = hoot.get('node.matcher.strictness');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 2;
  },

  /**
   * If the output file/layer exists when exporting, append the data instead of trying to create
   * a new
   * file/layer.
   */
  getOgrAppendData : function()
  {
      var tmp = hoot.get('ogr.append.data');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Debugging: Add the FCODE as the OSM source:fcode tag during translation.
   */
  getOgrDebugAddfcode : function()
  {
      var tmp = hoot.get('ogr.debug.addfcode');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Debugging: Print out Attributes and OSM Tag values during translation. For each feature,
   * this will
   * show what keys and values go into the translation and what the translated output is.
   */
  getOgrDebugDumptags : function()
  {
      var tmp = hoot.get('ogr.debug.dumptags');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Debugging: Print out which attributes are dropped during export validation.
   */
  getOgrDebugDumpvalidate : function()
  {
      var tmp = hoot.get('ogr.debug.dumpvalidate');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Debugging: When building internal lookup tables, print values that clash.
   */
  getOgrDebugLookupclash : function()
  {
      var tmp = hoot.get('ogr.debug.lookupclash');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Debugging: Print the columns that are not matched during one2one translation. This will show
   * all
   * Attribute columns and values that do not match a one2one rule.
   */
  getOgrDebugLookupcolumn : function()
  {
      var tmp = hoot.get('ogr.debug.lookupcolumn');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * The regexp to be used to filter the layer names when importing layers from an ESRI File
   * Geodatabase. The default is to import all layers from a FGDB.  Setting this variable will
   * override the filter value that can be set by the layerNameFilter function inside a
   * translation
   * script.
   */
  getOgrImportFilter : function()
  {
      var tmp = hoot.get('ogr.import.filter');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The number of identical log messages that will be emitted before they're silenced.
   */
  getOgrLogLimit : function()
  {
      var tmp = hoot.get('ogr.log.limit');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 3;
  },

  /**
   * When exporting to MGCP:
   * - "file" Save the unused tags in a new layer (extra_[PLA]).
   * - "note" Add unused tags to the "TXT" field.
   * - "none" Don't save the unused tags, just drop them.
   *
   * NOTE: According to the MGCP and Shapefile specifications, the "TXT" field has a maximum
   * length of 255 characters. Extra text will be truncated.
   */
  getOgrMgcpExtra : function()
  {
      var tmp = hoot.get('ogr.mgcp.extra');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "file";
  },

  /**
   * Write partial translations instead of o2s_[PAL] features.
   */
  getOgrPartialTranslate : function()
  {
      var tmp = hoot.get('ogr.partial.translate');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * If specified the OGR reader will limit data read from the data source to only features that
   * intersect the given bounding box. The format is "minx,miny,maxx,maxy" specified in the
   * projection
   * of the input data source.
   *
   * The method OGRLayer::SetSpatialFilterRect is used to limit the bounding box. Some formats
   * will
   * intelligently use indexes, others will simply filter features after reading from the data
   * source.
   *
   * Example Usage:
   *
   * ----
   * hoot ogr2osm -D ogr.reader.bounding.box=106.851,-6.160,107.052,-5.913
   * translations/Identity.js output.osm test-files/jakarta_raya_coastline.shp
   * ----
   */
  getOgrReaderBoundingBox : function()
  {
      var tmp = hoot.get('ogr.reader.bounding.box');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Similar to `ogr.reader.bounding.box` but uses WGS84 to specify the bounds rather than the
   * source
   * projection. Only one of the two options can be specified.
   *
   * A best effort will be made to convert between the two projections. The translated bounding
   * box
   * will approximate the minimum bounding rectangle of the lat/lng bounding box. In some cases
   * this
   * may be significantly larger.
   */
  getOgrReaderBoundingBoxLatlng : function()
  {
      var tmp = hoot.get('ogr.reader.bounding.box.latlng');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * If specified the OGR reader will override the reported projection with the specified EPSG
   * code. If
   * the value is < 0 then the projection reported by the source data set will be used. In most
   * cases
   * the default value is fine.
   *
   * This can sometimes be necessary when reading from a DB created with osm2pgsql. E.g.
   *
   * ----
   * hoot convert -D ogr.reader.epsg.override=900913 PG:"dbname='gis' host='localhost'
   * port='5432' user='hoot' password='blahblah'" tmp/output.shp
   * ----
   */
  getOgrReaderEpsgOverride : function()
  {
      var tmp = hoot.get('ogr.reader.epsg.override');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return -1;
  },

  /**
   * If the list of o2s tags is > 255 char, split it into into 254 char long pieces. If this is
   * false,
   * it will be exported as one big string.
   */
  getOgrSplitO2s : function()
  {
      var tmp = hoot.get('ogr.split.o2s');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Turn errors into warnings or off. Valid values are: on, off, warn
   */
  getOgrStrictChecking : function()
  {
      var tmp = hoot.get('ogr.strict.checking');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "on";
  },

  /**
   * Add the eLTDS specific attributes (SCAMIN, SCAMAX, LINK_ID) to the output
   */
  getOgrTdsAddEtds : function()
  {
      var tmp = hoot.get('ogr.tds.add.etds');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * Add the ESRI specific FCSUBTYPE field to the output
   */
  getOgrTdsAddFcsubtype : function()
  {
      var tmp = hoot.get('ogr.tds.add.fcsubtype');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * When exporting to TDSv40 and TDSv61:
   * - "note" Add unused tags to the "ZI006_MEM" field.
   * - "file" Save the unused tags in a new layer (extra_[PLA]).
   * - "none" Don't save the unused tags, just drop them.
   *
   * NOTE: If exporting to Shapefile, this field will be truncated to 255 characters.
   */
  getOgrTdsExtra : function()
  {
      var tmp = hoot.get('ogr.tds.extra');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "note";
  },

  /**
   * The name to use for the ESRI Feature Dataset on export. Note: This only applies to ESRI File
   * Geodatabases.
   */
  getOgrTdsFdname : function()
  {
      var tmp = hoot.get('ogr.tds.fdname');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "TDS";
  },

  /**
   * Export TDS data in Thematic Groups (TransportationGroundCrv, StructurePnt etc) instead of
   * one
   * FCODE per file/layer (ROAD_L, BUILDING_P etc).
   */
  getOgrTdsStructure : function()
  {
      var tmp = hoot.get('ogr.tds.structure');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * For the schema switcher, throw errors instead of returning a partial translation/o2s_X
   * feature from a translation.
   */
  getOgrThrowError : function()
  {
      var tmp = hoot.get('ogr.throw.error');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Create all layers when using the OGR writer whether or not the layers contain features.
   * Setting
   * this to true can be useful when conforming to strict specifications.
   */
  getOgrWriterCreateAllLayers : function()
  {
      var tmp = hoot.get('ogr.writer.create.all.layers');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   *
   */
  getOgrWriterPreLayerName : function()
  {
      var tmp = hoot.get('ogr.writer.pre.layer.name');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Set the script to use with OGR writer. For example:
   *
   * ----
   * hoot --convert \
   *   -D ogr.writer.script=test-files/io/SampleTranslation.js \
   *   -D ogr.writer.pre.layer.name=bar \
   *   test-files/io/SampleTranslation.osm \
   *   PG:"dbname='osm_gis2' host='localhost' port='5432' user='hoot' password='hoottest'"
   * ----
   */
  getOgrWriterScript : function()
  {
      var tmp = hoot.get('ogr.writer.script');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Operations that should be applied to ingested data before saving the data.
   */
  getOgr2osmOps : function()
  {
      var tmp = hoot.get('ogr2osm.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MergeNearbyNodes;hoot::BuildingPartMergeOp";
  },

  /**
   * If true, the OSM changeset sql file writer will generate new ID's for elements being
   * created.
   * Otherwise, it will use the ID's of the elements passed to it.
   */
  getOsmChangesetSqlFileWriterGenerateNewIds : function()
  {
      var tmp = hoot.get('osm.changeset.sql.file.writer.generate.new.ids');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * Specifies the reader that the OsmMapReaderFactory will use. This overrides any information
   * derived
   * from the URL.
   */
  getOsmMapReaderFactoryReader : function()
  {
      var tmp = hoot.get('osm.map.reader.factory.reader');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Specifies the writer that the OsmMapWriterFactory will use. This overrides any information
   * derived
   * from the URL.
   */
  getOsmMapWriterFactoryWriter : function()
  {
      var tmp = hoot.get('osm.map.writer.factory.writer');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Turns on autoformatting (line breaks, indentation etc) for XML output.
   */
  getOsmMapWriterFormatXml : function()
  {
      var tmp = hoot.get('osm.map.writer.format.xml');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * Sets the value for a "schema" attribute when writeing a map to OSM XML.
   * NOTE: this will only be written if the value is not empty.
   */
  getOsmMapWriterSchema : function()
  {
      var tmp = hoot.get('osm.map.writer.schema');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * User specified operations for converting OSM files to OGR compatible file types.
   */
  getOsm2ogrOps : function()
  {
      var tmp = hoot.get('osm2ogr.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Email address of the osm api reader user.  Can be set here for debugging and testing.
   */
  getOsmapiDbReaderEmail : function()
  {
      var tmp = hoot.get('osmapi.db.reader.email');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * This is required when using the OsmApiDbAwareHootApiDbReader or
   * OsmApiDbAwareHootApiDbWriter.  It
   * makes Hoot API database reading/writing use the specified OSM API database as master for
   * determining
   * the sequencing of element ID's.
   */
  getOsmapidbIdAwareUrl : function()
  {
      var tmp = hoot.get('osmapidb.id.aware.url');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The maximum number of OSM elements that may be read from the hootapi services database into
   * a
   * single OSM map during a partial map read.
   */
  getPbfReaderMaxElementsPerPartialMap : function()
  {
      var tmp = hoot.get('pbf.reader.max.elements.per.partial.map');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 50000;
  },

  /**
   * Perturbation algorithm to use with the PERTY process.  Valid values is
   * hoot::DirectSequentialSimulation.
   *
   * Previously the full covariance method was also supported as described in Doucette et al.
   * However,
   * the newer DirectSequentialSimulation is more efficient and produces similar results. By
   * removing
   * the full covariance method we were able to simplify the build process and reduce maintenance
   * cost.
   */
  getPertyAlgorithm : function()
  {
      var tmp = hoot.get('perty.algorithm');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::DirectSequentialSimulation";
  },

  /**
   * If true, the data is rubbersheeted before conflation, moving perturbed data closer to
   * reference data.
   */
  getPertyApplyRubberSheet : function()
  {
      var tmp = hoot.get('perty.apply.rubber.sheet');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * The PERTY D value. When perty.algorithm is set to FullCovariance this is used in the
   * simplified
   * community sensor model. When perty.algorithm is set to DirectSequentialSimulation D is used
   * in
   * e ^ (-perty.grid.spacing / D). Defaults to 1000. Larger values result in a more correlated
   * permutation grid.
   */
  getPertyCsmD : function()
  {
      var tmp = hoot.get('perty.csm.D');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1000;
  },

  /**
   * The beta value used in the PERTY simplified community sensor model. This is only relevant
   * when
   * perty.algorithm is set to FullCovariance.
   */
  getPertyCsmBeta : function()
  {
      var tmp = hoot.get('perty.csm.beta');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 9;
  },

  /**
   * The number of duplicate POIs is set as `round(abs(N(0, sigma^2))) + 1`. Setting sigma to 0
   * will
   * guarantee that there will always be exactly one duplicate.
   */
  getPertyDuplicatePoiDuplicateSigma : function()
  {
      var tmp = hoot.get('perty.duplicate.poi.duplicate.sigma');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1.0;
  },

  /**
   * The distance that a feature is moved is based on the circular error of the source point. The
   * new point will be put within N(0, sigma^2) * moveMultiplier meters of the source point where
   * sigma is the standard deviation associated with the source point.
   */
  getPertyDuplicatePoiMoveMultiplier : function()
  {
      var tmp = hoot.get('perty.duplicate.poi.move.multiplier');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1.0;
  },

  /**
   * The probability of at least one duplicate being created. See setDuplicateSigma to determine
   * how many duplicates will be created.
   */
  getPertyDuplicatePoiP : function()
  {
      var tmp = hoot.get('perty.duplicate.poi.p');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.10;
  },

  /**
   * The size of the PERTY grid spacing in meters.
   */
  getPertyGridSpacing : function()
  {
      var tmp = hoot.get('perty.grid.spacing');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 100;
  },

  /**
   * The probability of a change to each character in the name. The expected number of changes is
   * `perty.name.change.p` * str.size().
   */
  getPertyNameChangeP : function()
  {
      var tmp = hoot.get('perty.name.change.p');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.05;
  },

  /**
   * The probability that a name will be modified.
   */
  getPertyNameP : function()
  {
      var tmp = hoot.get('perty.name.p');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.05;
  },

  /**
   * A list of operations that should be applied after the geometries have been shifted by PERTY.
   */
  getPertyOps : function()
  {
      var tmp = hoot.get('perty.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::PertyWaySplitVisitor;hoot::PertyWayGeneralizeVisitor;hoot::PertyRemoveRandomElementVisitor;hoot::PertyDuplicatePoiOp;hoot::PertyRemoveTagVisitor;hoot::PertyNameVisitor";
  },

  /**
   * The sigma rx parameter for PERTY (random error in X). This is only relevant when
   * perty.algorithm
   * is set to FullCovariance.
   */
  getPertyRandomErrorX : function()
  {
      var tmp = hoot.get('perty.random.error.x');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * The sigma ry parameter for PERTY (random error in Y). This is only relevant when
   * perty.algorithm
   * is set to FullCovariance.
   */
  getPertyRandomErrorY : function()
  {
      var tmp = hoot.get('perty.random.error.y');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * The probability that a feature will be removed.
   */
  getPertyRemoveRandomP : function()
  {
      var tmp = hoot.get('perty.remove.random.p');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.05;
  },

  /**
   * Set the probability that a tag will be removed.
   */
  getPertyRemoveTagP : function()
  {
      var tmp = hoot.get('perty.remove.tag.p');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.05;
  },

  /**
   * A list of tag keys which are exempt from the tag removal done by PertyRemoveTagsVisitor.
   * This is
   * useful for preventing the removal of tags Hootenanny relies on during conflation.
   */
  getPertyRemoveTagVisitorExemptTagKeys : function()
  {
      var tmp = hoot.get('perty.remove.tag.visitor.exempt.tag.keys');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "REF1;REF2;hoot:status;uuid";
  },

  /**
   * A list of tag keys which, rather than being removed by the PertyRemoveTagVisitor, will have
   * their
   * values replaced instead.  The tag keys in the list match one to one with the replacement
   * values in
   * perty.remove.tag.visitor.subsitution.values.
   */
  getPertyRemoveTagVisitorSubstitutionKeys : function()
  {
      var tmp = hoot.get('perty.remove.tag.visitor.substitution.keys');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "highway";
  },

  /**
   * A list of tag values which, should be substituted by PertyRemoveTagVisitor.  The tag values
   * in the
   * list match one to one with the replacement values in
   * perty.remove.tag.visitor.subsitution.keys.
   */
  getPertyRemoveTagVisitorSubstitutionValues : function()
  {
      var tmp = hoot.get('perty.remove.tag.visitor.substitution.values');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "road";
  },

  /**
   * Distance parameter (in meters) that determines how far out to search when trying to match
   * features
   * during conflation of reference and perturbed datasets.  This is equivalent in nature to the
   * 'error:circular' tag used in Hootenanny conflation, however this setting is used instead for
   * PERTY scoring only.
   */
  getPertySearchDistance : function()
  {
      var tmp = hoot.get('perty.search.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 15;
  },

  /**
   * A random seed integer passed to the random number generator accessed by PERTY to give
   * consistent
   * results over multiple runs. A value of -1 will generate a seed based on the time to provide
   * pseudo-random results in the output.  Other seed values will yield repeatable results when
   * the
   * same seed is used in consecutive calls to the PERTY related commands.
   */
  getPertySeed : function()
  {
      var tmp = hoot.get('perty.seed');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return -1;
  },

  /**
   * The sigma sx parameter for PERTY. This controls how much correlated error in the
   * X direction is in the output permutation. Units in meters.
   */
  getPertySystematicErrorX : function()
  {
      var tmp = hoot.get('perty.systematic.error.x');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 50;
  },

  /**
   * The sigma sy parameter for PERTY. This controls how much correlated error in the
   * Y direction is in the output permutation. Units in meters.
   */
  getPertySystematicErrorY : function()
  {
      var tmp = hoot.get('perty.systematic.error.y');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 50;
  },

  /**
   * A score variance in the range of 0.0 to 1.0 by which a `perty-test` test run score may vary
   * while still allowing the test run's status to be described as passing.  Test run score
   * differences
   * larger than this value will cause the test run's status to be described as failing.  If you
   * are
   * not sure what your expected scores should be and want to bypass this check, create a list
   * with
   * all entries equal to "1.0" of the same size as perty.test.num.runs, and then
   * set perty.test.allowed.score.variance to "1.0".  This effectively disables the score
   * validation.
   */
  getPertyTestAllowedScoreVariance : function()
  {
      var tmp = hoot.get('perty.test.allowed.score.variance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.025;
  },

  /**
   * Amount by which the dynamic input variables specified in perty.test.dynamic.variables are
   * incremented during each test run by perty-test.
   */
  getPertyTestDynamicVariableIncrement : function()
  {
      var tmp = hoot.get('perty.test.dynamic.variable.increment');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.1;
  },

  /**
   * Dynamic variable value initially assigned to a PERTY test dynamic variable when executed by
   * `perty-test`.
   */
  getPertyTestDynamicVariableStartValue : function()
  {
      var tmp = hoot.get('perty.test.dynamic.variable.start.value');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * A list of one or more numeric PERTY variables to be assigned a start value (specified in
   * perty.test.dynamic.variable.start.value) and then incremented once per test run by
   * `perty-test` (specified in perty.test.dynamic.variable.increment) to the value of.  The list
   * is
   * restricted to Hootenanny PERTY options only (perty.*) of a numeric type.
   */
  getPertyTestDynamicVariables : function()
  {
      var tmp = hoot.get('perty.test.dynamic.variables');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * A list of expected PERTY scores in the range of 0.0 to 1.0 for a `perty-test` run.  The
   * number of
   * scores must match the value assigned to perty.test.num.runs.  If you are not sure what your
   * expected scores should be and want to bypass this check, create a list with all entries
   * equal
   * to "1.0" of the same size as perty.test.num.runs, and then set
   * perty.test.allowed.score.variance
   * to "1.0".  This effectively disables the score validation.
   */
  getPertyTestExpectedScores : function()
  {
      var tmp = hoot.get('perty.test.expected.scores');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "1.0";
  },

  /**
   * If true, the `perty-test` will mark a test as failing if its test run score is higher than
   * the
   * expected score and outside of the allowable score variance; if false, will always allow
   * higher
   * test run scores to result in a passing test run, despite being outside of the allowable
   * score
   * variance.
   */
  getPertyTestFailOnBetterScore : function()
  {
      var tmp = hoot.get('perty.test.fail.on.better.score');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * If true, Hootenanny map statistics files are output for all PERTY outputs created by `perty-
   * test`.
   */
  getPertyTestGenerateMapStats : function()
  {
      var tmp = hoot.get('perty.test.generate.map.stats');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * The number of test runs executed by `perty-test`.  A single input variable, or multiple
   * variables
   * (specified in perty.test.dynamic.variable) assigned identical starting values (specified in
   * perty.test.dynamic.variable.start.value), is/are altered by an increment during each test
   * (specified in perty.test.dynamic.variable.increment).
   */
  getPertyTestNumRuns : function()
  {
      var tmp = hoot.get('perty.test.num.runs');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * The number of simulations per test run executed by `perty-test`.  A test run is made up of
   * multiple simulations.  Scores all simulation executed by the test run are averaged to give
   * the
   * final PERTY score for the test run.
   */
  getPertyTestNumSimulations : function()
  {
      var tmp = hoot.get('perty.test.num.simulations');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 3;
  },

  /**
   * Distance parameter (in meters) that determines to what degree a way is generalized by PERTY.
   * Higher values result in more generalization (more nodes are removed).
   */
  getPertyWayGeneralizeEpsilon : function()
  {
      var tmp = hoot.get('perty.way.generalize.epsilon');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * The probability between 0.0 and 1.0 that a way will be generalized by PERTY.
   */
  getPertyWayGeneralizeProbability : function()
  {
      var tmp = hoot.get('perty.way.generalize.probability');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.1;
  },

  /**
   * The minimum spacing, in meters, that may occur between nodes created by PERTY way splits.
   */
  getPertyWaySplitMinNodeSpacing : function()
  {
      var tmp = hoot.get('perty.way.split.min.node.spacing');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * The probability between 0.0 and 1.0 that a way will be split into multiple features by
   * PERTY.
   */
  getPertyWaySplitProbability : function()
  {
      var tmp = hoot.get('perty.way.split.probability');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.1;
  },

  /**
   * The PLACES `wd` value for calculating goodness.
   *
   * See also:
   *
   *  * _PLACES POI Conflation_, <<hootalgo>>
   */
  getPlacesDistanceWeight : function()
  {
      var tmp = hoot.get('places.distance.weight');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.1;
  },

  /**
   * The PLACES goodness threshold.
   *
   * See also:
   *
   *  * _PLACES POI Conflation_, <<hootalgo>>
   */
  getPlacesGoodnessThreshold : function()
  {
      var tmp = hoot.get('places.goodness.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.3;
  },

  /**
   * If the similarity score is less than this value then the POIs are not considered for match.
   *
   * See also:
   *
   *  * _PLACES POI Conflation_, <<hootalgo>>
   */
  getPlacesMinimumEditSimilarity : function()
  {
      var tmp = hoot.get('places.minimum.edit.similarity');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.8;
  },

  /**
   * Distance that is considered an exact match. Defaults to 1mm.
   */
  getPlacesPoiEpsilonDistance : function()
  {
      var tmp = hoot.get('places.poi.epsilon.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.001;
  },

  /**
   * The PLACES `ws` value for calculating goodness.
   *
   * See also:
   *
   *  * _PLACES POI Conflation_, <<hootalgo>>
   */
  getPlacesStringWeight : function()
  {
      var tmp = hoot.get('places.string.weight');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.9;
  },

  /**
   * Possible options include:
   *
   * * `hoot::GeneralizeTagMerger`
   * * `hoot::OverwriteTag2Merger`
   */
  getPlacesTagMerger : function()
  {
      var tmp = hoot.get('places.tag.merger');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::OverwriteTag2Merger";
  },

  /**
   * A list of scripts to include before loading the user's plugin script. The path will be
   * search as:
   * current directory (CWD), $CWD/rules, $HOOT_HOME/rules.
   */
  getPluginContextIncludes : function()
  {
      var tmp = hoot.get('plugin.context.includes');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "HootLib.js";
  },

  /**
   * The threshold at which a match is called a match for POIs.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiMatchThreshold : function()
  {
      var tmp = hoot.get('poi.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}");
  },

  /**
   * The threshold at which a miss is called a miss for POIs.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiMissThreshold : function()
  {
      var tmp = hoot.get('poi.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}");
  },

  /**
   * If the name similarity score is greater than this then the names are considered a match.
   * Scores
   * are 0 to 1 for similarity and -1 if there are no names present (null).
   */
  getPoiPolygonMatchNameThreshold : function()
  {
      var tmp = hoot.get('poi.polygon.match.name.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0.8;
  },

  /**
   * How far away from a polygon should name matches be considered reviews. This is a fixed value
   * in
   * meters that is added to the CE calculation.
   */
  getPoiPolygonMatchReviewDistance : function()
  {
      var tmp = hoot.get('poi.polygon.match.review.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 0;
  },

  /**
   * The threshold at which a match is called a match for PoiPolygon.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiPolygonMatchThreshold : function()
  {
      var tmp = hoot.get('poi.polygon.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}");
  },

  /**
   * The threshold at which a miss is called a miss for PoiPolygon.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiPolygonMissThreshold : function()
  {
      var tmp = hoot.get('poi.polygon.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}");
  },

  /**
   * The threshold at which a review is called a review for PoiPolygon. See
   * `conflate.review.threshold.default`.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiPolygonReviewThreshold : function()
  {
      var tmp = hoot.get('poi.polygon.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}");
  },

  /**
   * The threshold at which a review is called a review for POIs. See
   * `conflate.review.threshold.default`.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getPoiReviewThreshold : function()
  {
      var tmp = hoot.get('poi.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}");
  },

  /**
   * If true, then any element being written to an OSM API database via 'hoot convert' will have
   * the
   * "error:circular" tag written to the element, if that element has a positive circular error
   * value.
   * This operation can be slow for large amounts of data.  This is a temporary setting for holy
   * grail
   * that eventually needs to be removed.
   */
  getPostgresqlDumpfileWriterAddCircularErrorTag : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.add.circular.error.tag');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * If true, then the OSM API database ingest operation will check the ID sequences of the
   * target
   * database (one time only) to determine the starting changeset and element ID's to use for the
   * entire
   * write operation.  Enabling this setting precludes a user from having to specify the
   * "postgresql.dumpfile.writer.start.id.*" configuration options (it overrides them).  This
   * setting
   * must be used in conjunction with the "postgresql.dumpfile.writer.id.aware.url" setting.
   * IMPORTANT:
   * This setting should only be enabled in situations where a single user is writing to the
   * target OSM
   * API database (database is offline).  Since the command does not continuallly check for the
   * next
   * available ID (for performance reasons), ID conflict errors may occur if multiple users are
   * writing
   * to the database simultaneously when this option is enabled.
   */
  getPostgresqlDumpfileWriterAutoCalcIds : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.auto.calc.ids');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Value that will be set in the "user_id" field for all changesets added by the ingest
   * operation
   */
  getPostgresqlDumpfileWriterChangesetUserId : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.changeset.user.id');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * Count at which the load status of each element type should be logged.  e.g. With a value of
   * 100000,
   * you will see a element load status update message for every 100000 elements parsed.
   */
  getPostgresqlDumpfileWriterElementStatusCountInterval : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.element.status.count.interval');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 100000;
  },

  /**
   * This is required when "postgresql.dumpfile.writer.auto.calc.ids" is set to true.  It should
   * point
   * to the eventual target OSM API database.
   */
  getPostgresqlDumpfileWriterIdAwareUrl : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.id.aware.url');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Starting ID value for changesets created in a PostgreSQL dumpfile.
   */
  getPostgresqlDumpfileWriterStartIdChangeset : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.start.id.changeset');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * Starting ID value for nodes created in a PostgreSQL dumpfile.
   */
  getPostgresqlDumpfileWriterStartIdNode : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.start.id.node');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * Starting ID value for relations created in a PostgreSQL dumpfile.
   */
  getPostgresqlDumpfileWriterStartIdRelation : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.start.id.relation');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * Starting ID value for ways created in a PostgreSQL dumpfile.
   */
  getPostgresqlDumpfileWriterStartIdWay : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.start.id.way');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * If this value is set, the generated dumpfile will insert statements that add a user with the
   * specified email address to the database.
   */
  getPostgresqlDumpfileWriterUserEmail : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.user.email');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * If the `postgresql.dumpfile.writer.user.email` field is set, the user that is added to the
   * database will be assigned the user id set by this field.
   */
  getPostgresqlDumpfileWriterUserId : function()
  {
      var tmp = hoot.get('postgresql.dumpfile.writer.user.id');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1;
  },

  /**
   * By default add the `source:datetime` stamp when reading files. This is not honored by all
   * readers.
   */
  getReaderAddSourceDatetime : function()
  {
      var tmp = hoot.get('reader.add.source.datetime');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * By default should a reader use the file status from the file. Not honored by all readers.
   */
  getReaderUseFileStatus : function()
  {
      var tmp = hoot.get('reader.use.file.status');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Use this class for calculating the difference between element tags. If the difference is
   * exactly
   * 0 then they'll be a candidate for merging.
   */
  getRemoveDuplicateAreasDiff : function()
  {
      var tmp = hoot.get('remove.duplicate.areas.diff');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ExactTagDifferencer";
  },

  /**
   * The plugin name of a filter used to select the elements to delete.
   */
  getRemoveElementsVisitorFilter : function()
  {
      var tmp = hoot.get('remove.elements.visitor.filter');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Should it remove the elements recursively?
   */
  getRemoveElementsVisitorRecursive : function()
  {
      var tmp = hoot.get('remove.elements.visitor.recursive');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * A list of tag keys for which the RemoveTagVisitor to identify for removal on elements.
   */
  getRemoveTagVisitorKeys : function()
  {
      var tmp = hoot.get('remove.tag.visitor.keys');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Sets the reporting format to the type specified.  For now, 'json' is the only
   * reporting format. The reporting format controls the format in which things like
   * progress are reported.
   */
  getReporting : function()
  {
      var tmp = hoot.get('reporting');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * If set to true then debug symbols will be added to nodes and additional tags will be added
   * to
   * matched nodes. This is a destructive operation that is only useful when debugging and should
   * not
   * be used during serious conflation.
   */
  getRubberSheetDebug : function()
  {
      var tmp = hoot.get('rubber.sheet.debug');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Sets the minimum number of tie points that will be used when calculating a rubber
   * sheeting solution.
   */
  getRubberSheetMinimumTies : function()
  {
      var tmp = hoot.get('rubber.sheet.minimum.ties');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 10;
  },

  /**
   * If this configuration setting is set to true then the first layer is treated as the
   * reference
   * layer and will not be moved. If set to false the two layers will be moved towards each
   * other. The
   * weighting is determined based on the circular error.
   */
  getRubberSheetRef : function()
  {
      var tmp = hoot.get('rubber.sheet.ref');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Export some of the images used when evaluating the graph connections between two maps
   * (`score`
   * command).
   */
  getScoreGraphDebugImages : function()
  {
      var tmp = hoot.get('score.graph.debug.images');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Remove REF tags from nodes before match scoring when using the score-matches command.
   */
  getScoreMatchesRemoveNodes : function()
  {
      var tmp = hoot.get('score.matches.remove.nodes');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * List of scripts to use for matching features.
   */
  getScriptMatchScripts : function()
  {
      var tmp = hoot.get('script.match.scripts');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "rules/PolygonBuildings.js";
  },

  /**
   * The default search radius to use when conflating features. If two features are within the
   * search
   * radius then they will be considered for conflation.  If the value is -1 then the circular
   * error will
   * be used to calculate an appropriate search radius.  Not all feature matching routines will
   * honor
   * the default value.
   */
  getSearchRadiusDefault : function()
  {
      var tmp = hoot.get('search.radius.default');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return -1.0;
  },

  /**
   * The search radius to use when conflating generic lines.  See `search.radius.default`.
   */
  getSearchRadiusGenericLine : function()
  {
      var tmp = hoot.get('search.radius.generic.line');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}");
  },

  /**
   * The search radius to use when conflating generic polygons.  See `search.radius.default`.
   */
  getSearchRadiusGenericPolygon : function()
  {
      var tmp = hoot.get('search.radius.generic.polygon');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}");
  },

  /**
   * The search radius to use when conflating highways.  See `search.radius.default`.
   */
  getSearchRadiusHighway : function()
  {
      var tmp = hoot.get('search.radius.highway');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}");
  },

  /**
   * The search radius to use when conflating waterways.  Not used if
   * waterway.auto.calc.search.radius = true.  See `search.radius.default`.
   */
  getSearchRadiusWaterway : function()
  {
      var tmp = hoot.get('search.radius.waterway');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${search.radius.default}");
  },

  /**
   * Set the key member in the SetTagVisitor class.
   */
  getSetTagVisitorKey : function()
  {
      var tmp = hoot.get('set.tag.visitor.key');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Set the value member in the SetTagVisitor class.
   */
  getSetTagVisitorValue : function()
  {
      var tmp = hoot.get('set.tag.visitor.value');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Use this class for calculating the difference between element tags. If the difference is
   * exactly 0
   * then they'll be a candidate for merging.
   */
  getSmallWayMergerDiff : function()
  {
      var tmp = hoot.get('small.way.merger.diff');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ExactTagDifferencer";
  },

  /**
   * If highways are smaller than threshold and the tags matched then they will be merged
   * together into
   * a single way.
   */
  getSmallWayMergerThreshold : function()
  {
      var tmp = hoot.get('small.way.merger.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 15;
  },

  /**
   * Class to instantiate from the factory.
   */
  getStatsClass : function()
  {
      var tmp = hoot.get('stats.class');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::ScriptStatsComposer";
  },

  /**
   * Format type for the statistics generated from conflate.  Can be pdf, html or asciidoc.
   */
  getStatsFormat : function()
  {
      var tmp = hoot.get('stats.format');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "pdf";
  },

  /**
   * Path to the output document for the statistics.  If left empty it will not output to a file,
   * only
   * to screen.
   */
  getStatsOutput : function()
  {
      var tmp = hoot.get('stats.output');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Number of digits of precision to include in the output stats. This may not be honored by all
   * stats
   * backends, but will certainly work for the tab delimited text.
   */
  getStatsPrecision : function()
  {
      var tmp = hoot.get('stats.precision');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 17;
  },

  /**
   * Path to the statistics generator rules in javascript format.
   */
  getStatsScript : function()
  {
      var tmp = hoot.get('stats.script');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/report/csr-default.js");
  },

  /**
   * Path to the translation script to use when translating tags for stats. If the path is empty
   * then
   * all translation stats are disabled.
   */
  getStatsTranslateScript : function()
  {
      var tmp = hoot.get('stats.translate.script');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/translations/TDSv61.js");
  },

  /**
   * The default status to match with a status criterion.
   */
  getStatusCriterionStatus : function()
  {
      var tmp = hoot.get('status.criterion.status');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "Invalid";
  },

  /**
   * The default ancestor to use when using the hoot::TagAncestorDifferencer class for comparing
   * tags.
   * Primarily this is useful within the node.js interface.
   */
  getTagAncestorDifferencerName : function()
  {
      var tmp = hoot.get('tag.ancestor.differencer.name');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The default category to use when using the hoot::TagCategoryDifferencer class for comparing
   * tags.
   * Primarily this is useful within the node.js interface.
   */
  getTagCategoryDifferencerName : function()
  {
      var tmp = hoot.get('tag.category.differencer.name');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * A key value pair to use in the tag criterion by default. E.g. 'highway,road'
   */
  getTagCriterionKvp : function()
  {
      var tmp = hoot.get('tag.criterion.kvp');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Specifies the default way of merging tags. This is used by most merge routines, but may be
   * overriden
   * depending on the specifics of the merger.
   *
   * Possible options include:
   *
   * * <<Average-Tags,`hoot::AverageTagMerger`>> - Attempts to take the average of the two tag
   * sets.
   * * <<Generalize-Tag-Merger,`hoot::GeneralizeTagMerger`>> - Attempt to take the most general
   *   interpretation of the tags.
   * * `hoot::OverwriteTagMerger` - Aliased to `hoot::OverwriteTag2Merger`
   * * <<Overwrite-Tag-1,`hoot::OverwriteTag1Merger`>> - Overwrite the tags in the first input.
   * * <<Overwrite-Tag-2,`hoot::OverwriteTag2Merger`>> - Overwrite the tags in the second input.
   */
  getTagMergerDefault : function()
  {
      var tmp = hoot.get('tag.merger.default');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::OverwriteTag2Merger";
  },

  /**
   * Output format to use when printing OSM+ Tag documentation. Valid formats are: csv, html,
   * redmine &
   * asciidoc (default)
   */
  getTagPrintingFormat : function()
  {
      var tmp = hoot.get('tag.printing.format');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "asciidoc";
  },

  /**
   * The translation script to use when printing OSM+ Tag documentation.
   */
  getTagPrintingScript : function()
  {
      var tmp = hoot.get('tag.printing.script');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${HOOT_HOME}/translations/PrintOsmDocs.js");
  },

  /**
   * The key to replace with by the TagRenameKeyVisitor.
   */
  getTagRenameVisitorNewKey : function()
  {
      var tmp = hoot.get('tag.rename.visitor.new.key');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The key to be replaced by the TagRenameKeyVisitor.
   */
  getTagRenameVisitorOldKey : function()
  {
      var tmp = hoot.get('tag.rename.visitor.old.key');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Always force the orthographic projection when determining a proper planar projection. In
   * typical
   * usage this will never be used (the automatically selected projection should always be at
   * least as
   * good). This is most useful if you want to get consistent results even if the list of
   * potential
   * projections change over time. Very handy in unit tests.
   */
  getTestForceOrthographicProjection : function()
  {
      var tmp = hoot.get('test.force.orthographic.projection');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * This does a rudimentary check to see if the string contains any letters/numbers. If the
   * string
   * doesn't contain any letters or numbers then it will be dropped. Examples that would be
   * dropped
   * if the value is `true` include:
   *
   * * `&`
   * * `--`
   *
   * Examples that will be kept if the value is `true` include:
   *
   * * `1&2`
   * * `Joe's`
   */
  getTokenKeepNonWords : function()
  {
      var tmp = hoot.get('token.keep.non.words');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * This is the minimum string size that the string tokenizer should accept as a token. If the
   * string
   * length is less than this value, then it will not be accepted. Set the value to 0 if you want
   * to
   * accept all strings.
   *
   * This setting primarily applies to string comparison functions and will eliminate comparing
   * very
   * short strings such as "of" or "&".
   */
  getTokenMinSize : function()
  {
      var tmp = hoot.get('token.min.size');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 3;
  },

  /**
   * The token separator defined as a regular expression. This is used in some methods for
   * tokenizing
   * names. The default value matches multiple whitespace characters.
   *
   * Another useful option is `[\s-,';]+`. This will split on white space, or several forms of
   * punctuation. See http://doc.qt.io/qt-4.8/QRegExp.html for a useful list of regular
   * expression
   * options.
   */
  getTokenSeparator : function()
  {
      var tmp = hoot.get('token.separator');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "\s+";
  },

  /**
   * Set to true if the strings should be tokenized (split into words) before translating the
   * values.
   */
  getTranslateStringDistanceTokenize : function()
  {
      var tmp = hoot.get('translate.string.distance.tokenize');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * List of tags that should be ignored when comparing a list of tags using the
   * hoot::TranslatedTagDifferencer.
   *
   * See also:
   * * `translated.tag.differencer.script`
   */
  getTranslatedTagDifferencerIgnoreList : function()
  {
      var tmp = hoot.get('translated.tag.differencer.ignore.list');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Path to the translation script when using the hoot::TranslatedTagDifferencer. The
   * hoot::TranslatedTagDifferencer is most useful when deciding how difference between two sets
   * of
   * tags should be calculated.
   *
   * This differencer can be used with:
   *
   * * `small.way.merger.diff`
   * * `remove.duplicate.areas.diff`
   */
  getTranslatedTagDifferencerScript : function()
  {
      var tmp = hoot.get('translated.tag.differencer.script');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * The direction that the translation script should translate. `toogr` will
   * translate from OSM to OGR. `toosm` will translate from OSM to OGR. This is
   * useful with the hoot::TranslationOp.
   */
  getTranslationDirection : function()
  {
      var tmp = hoot.get('translation.direction');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "toosm";
  },

  /**
   * Script to use for translation.
   */
  getTranslationScript : function()
  {
      var tmp = hoot.get('translation.script');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Enable the calculation of Optimal Constrained Matches during conflation. When enabled,
   * Hootenanny
   * will use either Optimal Constrained Matches (via GLPK) or Greedy Constrained Matches. If
   * disabled,
   * Hootenanny will only use Greedy Constrained Matches.
   */
  getUnifyEnableOptimalConstrainedMatches : function()
  {
      var tmp = hoot.get('unify.enable.optimal.constrained.matches');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * The maximum amount of time in seconds to wait for the optimizer to complete. A
   * value of -1 makes the time limit unlimited.
   *
   * If this value is set to something other than -1 your conflation results may
   * change between multiple runs. Especially if the machine Hoot is running on is
   * under heavy load. If the "CM Score:" value is changing between runs and GLPK
   * isn't finding an optimal solution then this is likely causing different output.
   * Just because the output is changing doesn't mean it is wrong, but this can be
   * problematic if you're doing testing or expecting repeatable output for other
   */
  getUnifyOptimizerTimeLimit : function()
  {
      var tmp = hoot.get('unify.optimizer.time.limit');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 30;
  },

  /**
   * Semi-colon delimited list of operations to apply after conflating.
   */
  getUnifyPostOps : function()
  {
      var tmp = hoot.get('unify.post.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::SuperfluousNodeRemover;hoot::SmallWayMerger";
  },

  /**
   * Semi-colon delimited list of operations to apply before conflating.
   */
  getUnifyPreOps : function()
  {
      var tmp = hoot.get('unify.pre.ops');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "";
  },

  /**
   * Creates a repeatable UUID for the features. This is useful for debugging, but shouldn't be
   * used in
   * normal operation.
   */
  getUuidHelperRepeatable : function()
  {
      var tmp = hoot.get('uuid.helper.repeatable');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Distance, in meters, used for sampling river data during angle histogram extraction with the
   * SampledAngleHistogramExtractor
   */
  getWaterwayAngleSampleDistance : function()
  {
      var tmp = hoot.get('waterway.angle.sample.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 20.0;
  },

  /**
   * Automatically calculates the search radius to be used during conflation of waterways using
   * rubber
   * sheet tie point distances.  When this setting is enabled, rubbersheeting is not allowed as a
   * pre-conflation operation on the input data to be conflated.
   */
  getWaterwayAutoCalcSearchRadius : function()
  {
      var tmp = hoot.get('waterway.auto.calc.search.radius');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * The threshold at which a match is called a match for waterways.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getWaterwayMatchThreshold : function()
  {
      var tmp = hoot.get('waterway.match.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.match.threshold.default}");
  },

  /**
   * The distance around a point on a waterway to look when calculating the heading. See
   * `way.matcher.heading.delta`.
   */
  getWaterwayMatcherHeadingDelta : function()
  {
      var tmp = hoot.get('waterway.matcher.heading.delta');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 150.0;
  },

  /**
   * Sets that maximum angle that is still considered a waterway match. Units in degrees.
   */
  getWaterwayMatcherMaxAngle : function()
  {
      var tmp = hoot.get('waterway.matcher.max.angle');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 90.0;
  },

  /**
   * The threshold at which a miss is called a miss for waterways.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getWaterwayMissThreshold : function()
  {
      var tmp = hoot.get('waterway.miss.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.miss.threshold.default}");
  },

  /**
   * The threshold at which a review is called a review for waterways.
   *
   * See also:
   *
   *  * _Estimate Pairwise Relationships_, <<hootalgo>>
   */
  getWaterwayReviewThreshold : function()
  {
      var tmp = hoot.get('waterway.review.threshold');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return hoot.getValue("${conflate.review.threshold.default}");
  },

  /**
   * Sets the minimum number of tie points that will be used when calculating a rubber sheeting
   * solution
   * with river data.
   */
  getWaterwayRubberSheetMinimumTies : function()
  {
      var tmp = hoot.get('waterway.rubber.sheet.minimum.ties');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 5;
  },

  /**
   * See `rubber.sheet.ref`.
   */
  getWaterwayRubberSheetRef : function()
  {
      var tmp = hoot.get('waterway.rubber.sheet.ref');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return true;
  },

  /**
   * The way subline matcher to use when determining matching sublines.
   */
  getWaterwaySublineMatcher : function()
  {
      var tmp = hoot.get('waterway.subline.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineMatcher";
  },

  /**
   * Distance, in meters, used for sampling way data during angle histogram extraction with the
   * SampledAngleHistogramExtractor
   */
  getWayAngleSampleDistance : function()
  {
      var tmp = hoot.get('way.angle.sample.distance');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 10.0;
  },

  /**
   * The distance around a point on a way to look when calculating the heading. A larger value
   * will
   * smooth out the heading values on a line. A smaller value will make the heading values
   * correspond
   * directly to the heading on the way at that point. This is primarily used in subline
   * matching.
   * Values are in meters.
   */
  getWayMatcherHeadingDelta : function()
  {
      var tmp = hoot.get('way.matcher.heading.delta');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 5.0;
  },

  /**
   * Sets that maximum angle that is still considered a way match. Units in degrees.
   */
  getWayMatcherMaxAngle : function()
  {
      var tmp = hoot.get('way.matcher.max.angle');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 60;
  },

  /**
   * If unset, or set to zero, there will be no maximum number of nodes stored in a way. If the
   * value is
   * set to a non-zero positive value, all way which contain more nodes than this value will be
   * broken
   * up into two or more separate ways, all of which will contain the number of nodes in this
   * value
   * (or less), and the original way will be removed from the map. Default set to 1900 as OSM
   * imports
   * through API DB are capped at 2000 nodes per way.
   */
  getWayMaxNodesPerWay : function()
  {
      var tmp = hoot.get('way.max.nodes.per.way');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1900;
  },

  /**
   * The minimum size that a way should be split into for merging. Units in meters.
   */
  getWayMergerMinSplitSize : function()
  {
      var tmp = hoot.get('way.merger.min.split.size');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 5;
  },

  /**
   * This configuration option is used by hoot::WaySplitterOp. If a way is longer than this
   * length
   * (in meters) then it will be split into smaller ways.
   */
  getWaySplitterMaxLength : function()
  {
      var tmp = hoot.get('way.splitter.max.length');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 5000;
  },

  /**
   * The way subline matcher to use when determining matching sublines.
   */
  getWaySublineMatcher : function()
  {
      var tmp = hoot.get('way.subline.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalNearestSublineMatcher";
  },

  /**
   * The way subline string matcher to use when determining matching sublines.
   */
  getWaySublineStringMatcher : function()
  {
      var tmp = hoot.get('way.subline.string.matcher');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MaximalSublineStringMatcher";
  },

  /**
   * Type of point aggregator used by the WeightedMetricDistanceExtractor.
   */
  getWeightedMetricDistanceExtractorPointAggregator : function()
  {
      var tmp = hoot.get('weighted.metric.distance.extractor.point.aggregator');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "hoot::MeanAggregator";
  },

  /**
   * The search radius used by the WeightedMetricDistanceExtractor.  Units in meters.  Defaults
   * to a
   * value computed from the circular error for each way being examined.
   */
  getWeightedMetricDistanceExtractorSearchRadius : function()
  {
      var tmp = hoot.get('weighted.metric.distance.extractor.search.radius');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return -1.0;
  },

  /**
   * Location of the abridged word frequency dictionary. This is not ideal and you'll get
   * repeated
   * warnings if you use it, but at least you won't need to download a 400MB+ file.
   */
  getWeightedWordDistanceAbridgedDictionary : function()
  {
      var tmp = hoot.get('weighted.word.distance.abridged.dictionary');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "WordsAbridged.sqlite";
  },

  /**
   * Location of the word frequency dictionary. If the absolute file path isn't found, then
   * the local `conf` and `$HOOT_HOME/conf` directories will be searched.
   *
   * This file is typically downloaded from:
   * https://s3.amazonaws.com/hoot-rpms/support-files/words1.sqlite.bz2
   */
  getWeightedWordDistanceDictionary : function()
  {
      var tmp = hoot.get('weighted.word.distance.dictionary');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return "words.sqlite";
  },

  /**
   * The weight used will be `1.0 / (w ^ p)` where w is the frequency. Valid values are >= 0, but
   * generally it should be `1 >= p >= 0`.
   */
  getWeightedWordDistanceP : function()
  {
      var tmp = hoot.get('weighted.word.distance.p');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 1.0;
  },

  /**
   * By default should a writer include debug information (e.g. status). Not honored by all
   * writers.
   */
  getWriterIncludeDebug : function()
  {
      var tmp = hoot.get('writer.include.debug');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return false;
  },

  /**
   * Set the output precision when writing. Not honored by all writers.
   */
  getWriterPrecision : function()
  {
      var tmp = hoot.get('writer.precision');
      if (tmp)
      {

        return tmp;
      }

      // Return the default value
      return 16;
  },

    } // End of config
