
== POI Merge Workflow High Level

This describes the current interactions between the user interface and web services that occur when a POI is merged.  All review tag changes are made via a client created changeset and all review related database records are updated by the server based on the contents of such changesets.

. User conflates POI data and begins the review process
. User advances to a review and merges two POI's which calls the POI merge service
. POI merge service returns back a merged POI
. For each of the POIs that were merged, the client (model/Conflicts.js) makes a review record references query (/reviewrefs) to the server which returns:
.. The IDs of all POIs each merged POI were still yet to be reviewed against
.. The IDs of all POIs that expected to be reviewed against each merged POI
. On the client (model/Conflicts.js): the newly created, combined merged POI sent back by the POI merge service is set to be reviewed against all of the POIs each merged POI were yet to be reviewed against (the hoot:review:uuid tag of the new, merge POI is modified with these IDs) this can result in 0 to many POI IDs being added
. On the client (model/Conflicts.js): for each POI that expected to be reviewed against each of the merged POIs, the IDs of the merged POIs are removed from those POIs and the ID of the newly created, combined merged POI is added in their place (the hoot:review:uuid tag of the new, merge POI is modified with these IDs); this can result in 0 to many POI IDs being added
. On the client (model/Conflicts.js): Any POI which was modified with no IDs remaining in its hoot:review:uuid tag as a result of the previous steps has all of its review tags removed.
. User resolves POI review
. Client (model/Conflicts.js) creates an OSM changeset containing:
.. A delete OSM changeset with the two merged POIs
.. A create changeset with the newly created, combined merged POI
.. A modify changeset with 0 to n POIs depending upon the modifications made in the hoot:review:uuid tag manipulation steps above
. Client (control/Conflicts.js) sends changeset to server (ChangesetResource.java)
. Review tags are updated on the OSM nodes in the OSM database tables based on the uploaded changeset (ChangesetDbWriter.java)
. The server (ReviewItemsSynchronizer.java) reads the changeset to make related review table updates:
.. Any created nodes from the changeset that have IDs in their hoot:review:uuid tag get new review and element ID mapping records created
.. Any modified nodes from the changeset either:
... Have new review/element ID mapping records created for them based on the contents of their hoot:review:uuid tag
... Have existing review records updated based on the contents of their hoot:review:uuid tag
.. Any deleted nodes from the changeset either:
... have their review records marked as reviewed if IDs corresponding to both halves of a review record (reviewable AND review against) are in the delete changeset
... OR if the deleted nodes in the delete changeset belong to exactly one half of a review record (reviewable OR review against), those review records are deleted completely, b/c its assumed the client took care of patching up any orphaned review links caused by the merge in the contents of the modify changeset

