#!/usr/bin/perl -w

use strict;
use Fcntl;
use Math::Trig; # For tile number calculations
use POSIX qw(strftime);
use File::Temp qw(tempfile);

sub covertDecimalDegreesToNanodegrees($);
sub generatePgDumpfileFromOsm($$);
sub readNodes($$$$$$);
sub lon2x($);
sub lat2y($);
sub convertLatLonToTileNumber($$);
sub generateISO8601Time();

sub convertDecimalDegreesToNanodegrees($)
{
  my $decimalDegrees = shift(@_);
  #print("Input degrees: $decimalDegrees\n");

  my $nanoDegrees = sprintf("%10d", ($decimalDegrees * 10000000.0));
  #print( "In nanodegrees: $nanoDegrees\n" );

  return $nanoDegrees;
}

sub lon2x($)
{
  my $lon = shift(@_);

  # Note perl does not have a rounding function, so stackoverflow says
  #     stealing from printf is about as close as you can come
  return int(sprintf("%.0f", (($lon + 180.0) * 65535.0 / 360.0)))
}

sub lat2y($)
{
  my $lat = shift(@_);

  return int(sprintf("%.0f", (($lat + 90.0) * 65535.0 / 180.0)));
}

sub convertLatLonToTileNumber($$)
{
  my $lat = shift(@_);
  my $lon = shift(@_);

  my $y = lat2y($lat);
  my $x = lon2x($lon);

  my $tile = 0;

  for ( my $i = 15; $i >= 0; $i-- )
  {
    $tile = ($tile << 1) | (($x >> $i) & 1);
    $tile = ($tile << 1) | (($y >> $i) & 1);
  }

  #print( "Tile calc for x=$lon, y=$lat: $tile\n");

  #exit;

  return $tile;
}

sub generateISO8601Time()
{
  return strftime("%F %T", gmtime(time()));
}


sub generatePgDumpfileFromOsm($$)
{
  my $osmFilename = shift(@_);
  my $sqlFilename = shift(@_);
  my %idMappings;
  my $osmFilehandle;

  open( $osmFilehandle, "< $osmFilename") or die( "Could not open OSM file: $osmFilename\n\n" );

  # Open multiple temp output SQL files and do ONE pass over each kind of data, dropping data
  #   into the appropriate file:
  #
  #   - User/changeset data
  #   - Current node/way/relation data
  #   - Historical node/way/relation data
  #
  #   At the end we'll do an OS filesystem concat of the three files to get the correct ordering of 
  #   sections which will be way faster than multiple passes over the exact same data

  my $currentSqlFilehandle = File::Temp->new();

  my $historicalSqlFilehandle = File::Temp->new();
   

  my $changesetId     = 1;
  my $startingNodeId  = 500;

  readNodes($osmFilehandle, $currentSqlFilehandle, $historicalSqlFilehandle, \$changesetId, 
    $startingNodeId, \%idMappings );

  print( "\nShould be first way line:\n\t" . <$osmFilehandle> );

  close( $osmFilehandle );
  #close( $sqlFilehandle );

  # concat temp file contents, delete temp files
  print( "Temp current SQL file: $currentSqlFilehandle\n");
  print( "Temp historical SQL file: $historicalSqlFilehandle\n");

  `cat $currentSqlFilehandle > $sqlFilename`;
  `cat $historicalSqlFilehandle >> $sqlFilename`;

}

sub readNodes($$$$$$)
{
  my $osmFilehandle             = shift(@_);
  my $currentSqlFilehandle      = shift(@_);
  my $historicalSqlFilehandle   = shift(@_);
  my $changesetIdRef            = shift(@_);
  my $startingNodeId            = shift(@_);
  my $idMappings                = shift(@_);

  print( "- Processing nodes: ");

  print( $currentSqlFilehandle 
    'COPY current_nodes (id, latitude, longitude, changeset_id, ' .
    "visible, \"timestamp\", tile, version) FROM stdin;\n" );
 
  print( $historicalSqlFilehandle
    'COPY nodes (node_id, latitude, longitude, changeset_id, visible, ' .
    '"timestamp", tile, version, redaction_id) FROM stdin;' . "\n" );

  my $changesInChangeset = 0;

  # Timestamp that will be used for all nodes
  my $timestamp = generateISO8601Time();

  # Read until we get something of interest (node, way, relation, or close OSM tag
  my $previousLinePosition = tell($osmFilehandle );
  my $currLine = <$osmFilehandle>;
  my $numNodes = 0;
  my $dbNodeId = $startingNodeId;
  while ( ! eof($osmFilehandle) )
  {
    chomp( $currLine );
    #print( "Read line: $currLine\n" );

    # If it's something past nodes, bail out
    if ( $currLine =~ /<(?:(?:way|relation) id=\"-?\d+\"|\/osm>)/ )
    {
      last;
    }

    # If it's a node, deal with it
    if ( $currLine =~ /<node\s+id=\"-?\d+\"/ )
    {
      #print( "Processing node in line $currLine" );
      $numNodes++;

      # Parse node line
      if ( $currLine !~ 
        /<node\s+id=\"(.+?)\"\s+lat=\"(.+?)\"\s+lon=\"(.+?)\"\s+/ )
      {
        print( "\nERROR: invalid node line $currLine, bailing\n\n");
        exit;
      }

      my $nodeId  = $1;
      my $nodeLat = $2;
      my $nodeLon = $3;
      my $tileNumber = convertLatLonToTileNumber($nodeLat, $nodeLon);

      # Establish node ID mapping
      if ( exists($idMappings->{'node'}->{$nodeId}) )
      {
        print("ERROR: node ID $nodeId not unique in input data!\n\n" );
        exit;
      }

      $idMappings->{'node'}->{$nodeId} = $dbNodeId;
      #print("Established node mapping, $nodeId -> $idMappings->{'node'}->{$nodeId}\n" );


      #print( "Tile number: " . convertLatLonToTileNumber($nodeLat, $nodeLon) . "\n" );
      

      # Print current version of data
      print( $currentSqlFilehandle
        sprintf("%d\t%10d\t%10d\t%d\tt\t%s\t%u\t1\n",
          $idMappings->{'node'}->{$nodeId},
          convertDecimalDegreesToNanodegrees($nodeLat),
          convertDecimalDegreesToNanodegrees($nodeLon),
          $$changesetIdRef,
          $timestamp,
          $tileNumber));


      # Print historical version of data
      print( $historicalSqlFilehandle
        sprintf( "%d\t%10d\t%10d\t%d\tt\t%s\t%u\t1\t\\N\n",
          $idMappings->{'node'}->{$nodeId},
          convertDecimalDegreesToNanodegrees($nodeLat),
          convertDecimalDegreesToNanodegrees($nodeLon),
          $$changesetIdRef,
          $timestamp,
          $tileNumber));


      #print( "Tile number: $tileNumber\n" );

      $dbNodeId++;

      $changesInChangeset++;
      if ( $changesInChangeset == 50000 )
      {
        $$changesetIdRef++;
        $changesInChangeset = 0;
      }
    }

    $previousLinePosition = tell($osmFilehandle );
    $currLine = <$osmFilehandle>;
  }

  # Output marker for end of tables
  print( $currentSqlFilehandle "\\.\n\n\n" );
  print( $historicalSqlFilehandle "\\.\n\n\n" );

  print ("complete ($numNodes)\n");

  print( "Sanity check: idMappings has " . scalar(keys(%{$idMappings->{'node'}})) . " entries\n" );

  #print( "Stopped looking for nodes at $currLine" ); 

  # Reset filehandle back one line so the next processing section starts at correct point
  $osmFilehandle = seek( $osmFilehandle, $previousLinePosition, Fcntl::SEEK_SET );
}


if ( scalar(@ARGV) != 2 ) 
{
  print( "Usage: convertOsmXmlToPgsqlDump <.osm input file> <.sql output file>\n\n" );
  exit;
}

my $osmFilename = $ARGV[0];
my $sqlFilename = $ARGV[1];

print( "OSM file: $osmFilename\n" );
print( "SQL file: $sqlFilename\n" );

print("\n");
generatePgDumpfileFromOsm( $osmFilename, $sqlFilename );
