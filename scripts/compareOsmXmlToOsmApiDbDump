#!/usr/bin/perl -w

# Compare the contents of an OSM XML file to a database dump (created with pg_dump) 
# of an OSM API database after that OSM XML file has been uploaded to it
#
# NOTE: this script requires the Perl module "XML::Simple" to be installed
#
# On Ubuntu 14.04, this can be installed using the following:
#
#     sudo apt-get install libxml-simple-perl

use strict;
require XML::Simple;

use XML::Simple qw(:strict);
use Data::Dumper;

sub parseOsmXmlNodes($);
sub validateOsmXmlNodes($$);
sub convertNanodegreesStringToDegrees($);

# Globals for data
my %nodesOsm;
my %nodesPgsql;

sub convertNanodegreesStringToDegrees($)
{
  my $nanodegreesString = shift(@_);

  return ( $nanodegreesString / 10000000.0 );
}

sub parseOsmXmlNodes($)
{
  my $xmlString = shift(@_);
  my $xs = XML::Simple->new();
  my $domRef = $xs->XMLin($xmlString, KeyAttr => { node=> 'id' }, ForceArray => [ 'node', 'tag' ] );

  return $domRef;
}

sub validateOsmXmlNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);
  my @dumpLines = @{$dumpLinesRef};

  my $currLine;

  # Checking table: current_nodes
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where current_nodes starts
    if ( $foundStart == 0 ) 
    {
      if ($currLine =~ /^COPY current_nodes .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    # Have a valid node
    my %currentNodesData;

    # Break into tokens based on whitespace delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    print( "Found node, ID = $tokens[0]\n");
  
    $currentNodesData{'latitude'} = convertNanodegreesStringToDegrees($tokens[1]);
    print( "\tLatitude: $currentNodesData{'latitude'}\n");
    last;

  }
    

  # Checking table: nodes


}

if ( scalar(@ARGV) != 2 ) 
{
  print( "Usage: compareOsmXmlToPgsqlDump <OSM XML file> <PostgreSQL pg_dump output file>\n\n");
  exit;
}

my $osmXmlFile = $ARGV[0];
my $pgsqlDumpFile = $ARGV[1];

open(XMLFILE, "< $osmXmlFile");
my @xmlLines = <XMLFILE>;
close(XMLFILE);

open(PGDUMPFILE, "< $pgsqlDumpFile" );
my @dumpLines = <PGDUMPFILE>;
close(PGDUMPFILE);

# Concat the XML contents into one string for parsing
my $concatOsmXml = join('', @xmlLines);

print( "OSM XML file:\t\t$osmXmlFile\nPostgreSQL dump file:\t$pgsqlDumpFile\n\n");

my $nodesDomRef = parseOsmXmlNodes($concatOsmXml);

validateOsmXmlNodes($nodesDomRef, \@dumpLines );

