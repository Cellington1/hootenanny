#!/usr/bin/perl -w

# Compare the contents of an OSM XML file to a database dump (created with pg_dump) 
# of an OSM API database after that OSM XML file has been uploaded to it
#
# NOTE: this script requires the Perl module "XML::Simple" to be installed
#
# On Ubuntu 14.04, this can be installed using the following:
#
#     sudo apt-get install libxml-simple-perl

use strict;
require XML::Simple;

use XML::Simple qw(:strict);
use Data::Dumper;

sub parseOsmXmlNodes($);
sub validateOsmXmlNodes($$);
sub convertNanodegreesStringToDegrees($);

# Globals for data
my %nodesOsm;
my %nodesPgsql;

sub convertNanodegreesStringToDegrees($)
{
  my $nanodegreesString = shift(@_);

  return ( $nanodegreesString / 10000000.0 );
}

sub parseOsmXmlNodes($)
{
  my $xmlString = shift(@_);
  my $xs = XML::Simple->new();
  my $domRef = $xs->XMLin($xmlString, KeyAttr => { node=> 'id' }, ForceArray => [ 'node', 'tag' ] );

  return $domRef;
}

sub validateOsmXmlNodes($$)
{
  my $osmXmlNodesRef = shift(@_);
  my $dumpLinesRef = shift(@_);
  my @dumpLines = @{$dumpLinesRef};

  my %currentNodesData;

  my $currLine;

  # Checking table: current_nodes
  my $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where current_nodes starts
    if ( $foundStart == 0 ) 
    {
      if ($currLine =~ /^COPY current_nodes .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    #print( "Current_nodes entry: $currLine\n" );

    # Have a valid node
    my %currentNodesEntry;

    # Break into tokens based on whitespace delimiter
    # Schema: id, latitude, longitude, changeset_id, visible, "timestamp", tile, version
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node, ID = $tokens[0]\n");
  
    $currentNodesEntry{'lat'} = convertNanodegreesStringToDegrees($tokens[1]);
    #print( "\tLatitude: $currentNodesEntry{'lat'}\n");

    $currentNodesEntry{'lon'} = convertNanodegreesStringToDegrees($tokens[2]);
    #print( "\tLongitude: $currentNodesEntry{'lon'}\n");

    $currentNodesEntry{'tile_num'} = $tokens[7];
    $currentNodesEntry{'version'} = $tokens[8];

    #print( "\tCoords (lat/lon): $currentNodesEntry{'lat'}, $currentNodesEntry{'lon'}\n");
    #print( "\tTile: $currentNodesEntry{'tile_num'}\n");
    #print( "\tVersion: $currentNodesEntry{'version'}\n");

    # Store the entry in hash of current_nodes
    $currentNodesData{$tokens[0]} = \%currentNodesEntry;
  }

  print( 'Found ' . scalar(keys(%currentNodesData)) . " entries in current_nodes\n" );

  # Read current_node_tags

  $foundStart = 0;
  foreach $currLine (@dumpLines)
  {
    chomp($currLine);

    # Find out where table data starts
    if ( $foundStart == 0 )
    {
      if ($currLine =~ /^COPY current_node_tags .+ FROM stdin;/ )
      {
        $foundStart = 1;
      }

      # Either way, can't do any more processing
      next;
    }

    # Are we at end of data?
    if ( $currLine =~ /^\\./ )
    {
      last;
    }

    print( "Current_node_tags entry: $currLine\n" );

    # Have a valid node
    my %currentNodeTagsEntry;

    # Break into tokens based on whitespace delimiter
    # Schema: node_id, key, value
    my @tokens = split( /\s+/, $currLine);

    #print( "Found node tag\n");

    $currentNodeTagsEntry{$tokens[1]} = $tokens[2];
    print( "\tID: $tokens[0]\n\tKey: $tokens[1]\n\tValue: $tokens[2]\n");

    # Store the entry in hash of current_nodes
    if ( exists($currentNodesData{ $tokens[0 ] }->{'tags'} ) )
    {
      $currentNodesData{ $tokens[0] }->{'tags'}->{$tokens[1]} = $tokens[2];

      #my $key;
      #foreach $key ( keys( $currentNodesData{ $tokens[0] }->{'tags'}) )
      #{
      # print( "\tFound tags key: $key\n" );
      #}
    }
    else
    {
      $currentNodesData{ $tokens[0] }->{'tags'} = { $tokens[1] => $tokens[2] };
    }
  }
}


if ( scalar(@ARGV) != 2 ) 
{
  print( "Usage: compareOsmXmlToPgsqlDump <OSM XML file> <PostgreSQL pg_dump output file>\n\n");
  exit;
}

my $osmXmlFile = $ARGV[0];
my $pgsqlDumpFile = $ARGV[1];

open(XMLFILE, "< $osmXmlFile");
my @xmlLines = <XMLFILE>;
close(XMLFILE);

open(PGDUMPFILE, "< $pgsqlDumpFile" );
my @dumpLines = <PGDUMPFILE>;
close(PGDUMPFILE);

# Concat the XML contents into one string for parsing
my $concatOsmXml = join('', @xmlLines);

print( "OSM XML file:\t\t$osmXmlFile\nPostgreSQL dump file:\t$pgsqlDumpFile\n\n");

my $nodesDomRef = parseOsmXmlNodes($concatOsmXml);

validateOsmXmlNodes($nodesDomRef, \@dumpLines );

